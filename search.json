{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"Sōzu","text":"","path":["Sōzu"],"tags":[]},{"location":"#sozu_1","level":2,"title":"Sōzu 是什么？","text":"<p>Sōzu 是一个用 Rust 编写的用于负载均衡的反向代理。它的主要工作是在两个或多个集群后端之间平衡入站请求，以分散负载。</p> <ul> <li> <p>它作为 TLS 会话的终止点。因此，处理加密的工作负载从后端卸载。</p> </li> <li> <p>它可以通过阻止来自网络的直接访问来保护后端。</p> </li> <li> <p>它返回一些与其后面的客户端和后端集群之间流量相关的指标。</p> </li> </ul>","path":["Sōzu"],"tags":[]},{"location":"#_1","level":2,"title":"介绍","text":"<ul> <li> <p>入门</p> </li> <li> <p>配置 Sōzu</p> </li> <li> <p>如何使用它</p> </li> <li> <p>为什么你应该使用 Sōzu</p> </li> <li> <p>设计动机</p> </li> <li> <p>技巧</p> </li> </ul>","path":["Sōzu"],"tags":[]},{"location":"#_2","level":2,"title":"概述","text":"<ul> <li> <p>架构概述</p> </li> <li> <p>工具和库</p> </li> </ul>","path":["Sōzu"],"tags":[]},{"location":"#_3","level":2,"title":"深入","text":"<ul> <li>会话的生命周期</li> </ul>","path":["Sōzu"],"tags":[]},{"location":"#_4","level":2,"title":"发行说明","text":"<p>待办</p>","path":["Sōzu"],"tags":[]},{"location":"#_5","level":2,"title":"演示和幻灯片","text":"<ul> <li> <p>Sōzu，一个可热重构的反向 HTTP 代理，作者：Geoffroy Couprie</p> </li> <li> <p>(法语) 2017 年重构反向代理以实现不可变基础设施，作者：Quentin Adam</p> </li> </ul>","path":["Sōzu"],"tags":[]},{"location":"architecture/","level":1,"title":"架构","text":"<p>这部分主要面向希望了解 sōzu 工作原理的人。</p>","path":["架构"],"tags":[]},{"location":"architecture/#_2","level":2,"title":"主/工作进程模型","text":"<p>Sōzu 采用一个主进程和多个工作进程的模式。这使得当一个工作进程遇到问题并崩溃时，它能继续运行，并在必要时逐个升级工作进程。</p>","path":["架构"],"tags":[]},{"location":"architecture/#_3","level":3,"title":"单线程，无共享架构","text":"<p>每个工作进程运行一个单线程，并带有一个基于 epoll 的事件循环。为避免同步问题，每个工作进程都拥有整个路由配置的副本。路由的每一次修改都通过配置消息进行。日志和指标由每个工作进程单独发送，将聚合和序列化事件的工作留给外部服务。 所有监听的 TCP 套接字都使用 SO_REUSEPORT 选项打开，允许多个进程在同一地址上监听。</p>","path":["架构"],"tags":[]},{"location":"architecture/#_4","level":3,"title":"配置","text":"<p>外部工具通过一个 unix 套接字与主进程交互，配置更改消息将由主进程分发给工作进程。 配置消息是“差异”，例如“添加一个后端服务器”或“删除一个 HTTP 前端”，而不是一次性更改整个配置。这使得 sōzu 能够在有流量的情况下更智能地处理配置更改。</p> <p>配置消息以 protobuf 二进制格式传输，它们定义在 command 库中。有三种可能的消息回复：processing（表示消息已收到但更改尚未生效）、failure 或 ok。</p> <p>主进程暴露一个用于配置的 unix 套接字，而不是在 localhost 上暴露一个 HTTP 服务器，因为 unix 套接字的访问可以通过文件系统权限来保护。</p>","path":["架构"],"tags":[]},{"location":"architecture/#_5","level":2,"title":"代理","text":"","path":["架构"],"tags":[]},{"location":"architecture/#mio","level":3,"title":"使用 mio 的事件循环","text":"<p>每个工作进程都运行一个基于 epoll（在 Linux 上）或 kqueue（在 OSX 和 BSD 上）的事件循环，使用 mio 库。</p> <p>Mio 提供了一个跨平台抽象，允许调用者接收事件，例如套接字变为可读（意味着它收到了一些数据）。</p> <p>Sōzu 要求 mio 以边缘触发模式发送套接字的所有事件。 这样，它只接收一次事件，并将其存储在一个 <code>Readiness</code> 结构体中。 然后它将使用该信息和“兴趣”（指示当前协议状态机是否想在套接字上读取或写入）。</p> <p>每个套接字事件都带有一个 <code>Token</code> 返回，指示其在 <code>Slab</code> 数据结构中的索引。一个客户端会话可以有多个套接字（通常是一个前端套接字和一个后端套接字）。</p>","path":["架构"],"tags":[]},{"location":"architecture/#_6","level":3,"title":"协议","text":"<p>每个代理实现（HTTP、HTTPS 和 TCP）将在每个客户端会话中使用一个状态机来描述当前使用的协议。它旨在允许从一个协议升级到下一个协议。例如，你可以有以下 progression：</p> <ul> <li>在 TLS 握手协议中启动</li> <li>握手完成后，升级到最近协商的 TLS 流上的 HTTP 协议</li> <li>升级到 websockets</li> </ul> <p>每个协议都将与 <code>Readiness</code> 结构一起工作，以指示它是否想在每个套接字上读取或写入。例如，基于 OpenSSL 的握手 只对前端套接字感兴趣。</p> <p>它们都在 <code>lib/src/network/protocol</code> 中定义。</p>","path":["架构"],"tags":[]},{"location":"architecture/#_7","level":2,"title":"日志记录","text":"<p>记录器 旨在使用 Rust 的格式化系统减少分配和字符串插值。它可以在各种后端上发送日志：stdout、文件、TCP、UDP、Unix 套接字。</p> <p>记录器可以通过一个线程局部存储变量从任何地方通过日志宏调用。</p>","path":["架构"],"tags":[]},{"location":"architecture/#_8","level":2,"title":"指标","text":"<p>指标 的工作方式与记录器类似，可以通过宏和 TLS 从任何地方访问。我们支持两种“drains”：一种通过 statsd 兼容协议在网络上发送指标，另一种在本地聚合指标，以通过配置套接字进行查询。</p>","path":["架构"],"tags":[]},{"location":"architecture/#_9","level":2,"title":"负载均衡","text":"<p>对于给定的集群，Sōzu 维护一个后端列表，连接将被重定向到这些后端。 Sōzu 检测损坏的服务器，并仅将流量重定向到健康的服务器，有多种可用的负载均衡算法： 轮询（默认）、随机、最少连接和二次幂。</p>","path":["架构"],"tags":[]},{"location":"architecture/#tls","level":2,"title":"TLS","text":"<p>Sōzu 是一个由 rustls 支持的 TLS 端点。 它使用 TLS 密钥和证书解密流量，并将其未加密地转发到后端。</p>","path":["架构"],"tags":[]},{"location":"architecture/#_10","level":2,"title":"深入探讨","text":"","path":["架构"],"tags":[]},{"location":"architecture/#_11","level":3,"title":"缓冲区","text":"<p>Sōzu 经过优化，内存使用非常有限。 所有流量都（短暂地）存储在一个固定大小（通常为 16 kB）的可重用缓冲区池中。</p>","path":["架构"],"tags":[]},{"location":"architecture/#_12","level":3,"title":"通道","text":"<p>它们是 unix 套接字之上的一个抽象层，使与 sōzu 的通信更容易。</p>","path":["架构"],"tags":[]},{"location":"benchmark/","level":1,"title":"如何对 Sōzu 进行基准测试/观察","text":"<p>用于调试和优化目的。</p>","path":["如何对 Sōzu 进行基准测试/观察"],"tags":[]},{"location":"benchmark/#sozu_1","level":2,"title":"在你的机器上运行 Sōzu，并使用虚拟后端","text":"","path":["如何对 Sōzu 进行基准测试/观察"],"tags":[]},{"location":"benchmark/#http-https","level":3,"title":"创建一个包含 HTTP 和 HTTPS 监听器的配置","text":"<p><code>bin/config.toml</code> 的大多数默认值都是合理的，将它们复制到 <code>bin/my-config.toml</code> 中。 一个需要调整的重要值是 <code>worker_count</code>。只测试一个 工作进程的性能似乎是理想的：</p> <pre><code>worker_count = 1\n</code></pre> <p>HTTP 和 HTTPS 监听器应该是相同的。 为 HTTPS 监听器选择一个 TLS 版本和一个密码列表，并坚持使用它。</p> <pre><code>[[listeners]]\nprotocol = \"http\"\naddress = \"0.0.0.0:8080\"\n\n[[listeners]]\nprotocol = \"https\"\naddress = \"0.0.0.0:8443\"\ntls_versions = [\"TLS_V13\"]\n\ncipher_list = [\n  # \"TLS13_AES_128_GCM_SHA256\",\n  \"TLS13_CHACHA20_POLY1305_SHA256\",\n  # ...\n]\n</code></pre> <p>创建一个集群（相当于一个应用程序），它有两个前端： 一个用于 HTTP 请求，一个用于 HTTPS 请求。</p> <p>确保你为 <code>localhost</code> 域创建了自己的证书和密钥。</p> <pre><code>frontends = [\n    { address = \"0.0.0.0:8080\", hostname = \"localhost\", path = \"/api\" },\n    { address = \"0.0.0.0:8443\", hostname = \"localhost\", certificate = \"/path/to/your/certificate.pem\", key = \"/path/to/your/key.pem\", certificate_chain = \"/path/to/your/certificate.pem\" },\n]\n</code></pre> <p>或者使用 <code>config.toml</code> 的证书、密钥和证书链， 它们位于 <code>/lib/assets/</code> 中。 但这样你就必须使用 <code>lolcatho.st</code> 作为本地域， 并确保你的 <code>/etc/hosts</code> 中有以下几行：</p> <pre><code>127.0.0.1       lolcatho.st\n::1             lolcatho.st\n</code></pre>","path":["如何对 Sōzu 进行基准测试/观察"],"tags":[]},{"location":"benchmark/#4","level":3,"title":"生成 4 个后端","text":"<p>创建四个简单的 HTTP 服务器，当通过 HTTP GET 请求 <code>/api</code> 路径（任意）时，每个服务器都返回 200 OK。 使用你喜欢的编程语言，它应该很简单。 这是 8 行 javascript。 确保每个后端都在 localhost 上监听，并且端口不同， 例如：1051、1052、1053、1054。</p> <p>将这些后端添加到 <code>my-config.toml</code> 的前端下方：</p> <pre><code>backends = [\n    { address = \"127.0.0.1:1051\", backend_id = \"backend_1\" },\n    { address = \"127.0.0.1:1052\", backend_id = \"backend_2\" },\n    { address = \"127.0.0.1:1053\", backend_id = \"backend_3\" },\n    { address = \"127.0.0.1:1054\", backend_id = \"backend_4\" },\n]\n</code></pre>","path":["如何对 Sōzu 进行基准测试/观察"],"tags":[]},{"location":"benchmark/#sozu_2","level":3,"title":"构建并运行 Sōzu","text":"<p>在发布模式下构建 Sōzu。</p> <pre><code>car go build --release\n</code></pre> <p>提示：重命名发布二进制文件并将其放入 cargo 路径中：</p> <pre><code>mv target/release/sozu $HOME/.cargo/bin/sozu-0.15.14\n</code></pre> <p>现在你可以在发布模式下运行 Sōzu：</p> <pre><code>cd bin\nsozu-0.15.14 --config my-config.toml start\n</code></pre> <p>通过 Sōzu 使用 curl 请求后端来检查 Sōzu 是否工作：</p> <pre><code>curl https://localhost:8443/api -v\ncurl http://localhost:8080/api  -v\n</code></pre>","path":["如何对 Sōzu 进行基准测试/观察"],"tags":[]},{"location":"benchmark/#bombardier","level":2,"title":"Bombardier","text":"<p>Bombardier 是一个用 go 编写的 HTTP 和 HTTPS 基准测试工具。 它在大多数 linux 发行版中都以软件包的形式提供， 并且在命令行中易于使用。</p>","path":["如何对 Sōzu 进行基准测试/观察"],"tags":[]},{"location":"benchmark/#_1","level":3,"title":"在一个连接上测试大量请求","text":"<pre><code>bombardier --connections=1 --requests=10000 https://localhost:8443/api --latencies\nbombardier --connections=1 --requests=10000 http://localhost:8080/api --latencies\n</code></pre>","path":["如何对 Sōzu 进行基准测试/观察"],"tags":[]},{"location":"benchmark/#_2","level":3,"title":"测试并发连接","text":"<pre><code>bombardier --connections=100 --requests=10000 https://localhost:8443/api --latencies\nbombardier --connections=100 --requests=10000 http://localhost:8080/api --latencies\n</code></pre> <p>增加连接数，直到 Sõzu 无法承受。</p>","path":["如何对 Sōzu 进行基准测试/观察"],"tags":[]},{"location":"benchmark/#tls-perf","level":2,"title":"TLS-perf","text":"<p><code>tls-perf</code> 是一个用 C 语言编写的 TLS 压力测试工具。 它没有依赖项，并且易于构建。</p> <pre><code>git clone git@github.com:tempesta-tech/tls-perf.git\ncd tls-perf\nmake\nmv tls-perf $HOME/.local/bin\n</code></pre> <p>假设 <code>$HOME/.local/bin</code> 在你的路径中。</p> <p>此命令执行： - 一万次 TLS 握手 - 仅使用一个连接 - 使用 TLS 1.3 版本</p> <pre><code>tls-perf \\\n  -n 10000 \\\n  -l 1 \\\n  --sni localhost \\\n  --tls 1.3 \\\n  127.0.0.1 8443\n</code></pre>","path":["如何对 Sōzu 进行基准测试/观察"],"tags":[]},{"location":"benchmark/#strace","level":2,"title":"使用 <code>strace</code> 查找系统调用","text":"<p><code>strace</code> 是一个诊断工具，可以监视 进程（Sōzu）和 linux 内核之间的交互。它在大多数 linux 发行版中都以软件包的形式提供。</p> <p>Sōzu 运行后，找到工作进程的 pid：</p> <pre><code>ps -aux | grep sozu\nuser   13368  0.7  0.1 188132 40344 pts/2    Sl+  11:35   0:00 /path/to/sozu --config my-config.toml start\nuser   14157  0.0  0.0  79908 29628 pts/2    S+   11:35   0:00 /path/to/sozu worker --id 0 --fd 5 --scm 7 --configuration-state-fd 3 --command-buffer-size 16384 --max-command-buffer-size 16384\nuser   14205  0.0  0.0   6556  2412 pts/3    S+   11:35   0:00 grep --color=auto sozu\n</code></pre> <p>第二行是工作进程，其 pid 是 <code>14157</code>。</p> <p>使用 strace 跟踪此 pid。你可能需要 root 权限。</p> <pre><code>strace --attach=14157\n</code></pre> <p>你应该会看到常规的 <code>epoll_wait</code> 系统调用，这是 Sōzu 的主循环。</p> <pre><code>epoll_wait(3, [], 1024, 1000)           = 0\nepoll_wait(3, [], 1024, 1000)           = 0\nepoll_wait(3, [], 1024, 1000)           = 0\nepoll_wait(3, [], 1024, 318)            = 0\n</code></pre> <p>如果你执行其中一个 curl，你将看到 Sōzu 在 HTTP 或 HTTPS 请求期间执行的所有系统调用。 以下是在一个简单的后端上进行 HTTP GET 期间发生的系统调用。 这只是在监听器套接字上接受流量。</p> <pre><code># 主循环等待事件\nepoll_wait(3, [], 1024, 1000)           = 0\n\n# 一个可读事件 (EPOLLIN)。一个客户端连接到监听器套接字。\nepoll_wait(3, [{events=EPOLLIN, data={u32=3, u64=3}}], 1024, 1000) = 1\n\n# 代理接受连接，通过告诉监听器接受\n# 套接字上的传入连接\naccept4(9, {sa_family=AF_INET, sin_port=htons(46144), sin_addr=inet_addr(\"127.0.0.1\")}, [128 =&gt; 16], SOCK_CLOEXEC|SOCK_NONBLOCK) = 11\n\n# 完成！没有更多连接要接受\naccept4(9, 0x7ffe89e39b98, [128], SOCK_CLOEXEC|SOCK_NONBLOCK) = -1 EAGAIN (Resource temporarily unavailable)\n\n# HTTP 代理在套接字上设置 NODELAY\nsetsockopt(11, SOL_TCP, TCP_NODELAY, [1], 4) = 0\n\n# Sōzu 在接受队列中注册套接字\n# 接受队列在另一个循环中弹出，以创建会话\n\n# 创建会话时，套接字在事件循环中注册\nepoll_ctl(6, EPOLL_CTL_ADD, 11, {events=EPOLLIN|EPOLLOUT|EPOLLRDHUP|EPOLLET, data={u32=267, u64=267}}) = 0\n\n# 获取套接字的地址（这里，主机相同，但端口不同）\ngetpeername(11, {sa_family=AF_INET, sin_port=htons(46144), sin_addr=inet_addr(\"127.0.0.1\")}, [128 =&gt; 16]) = 0\n\n# 返回主事件循环\nepoll_wait(3, [{events=EPOLLIN|EPOLLOUT, data={u32=267, u64=267}}], 1024, 1000) = 1\n\n# 我们已准备好让流量通过此套接字\n\n# 来了！\nrecvfrom(11, \"GET /api HTTP/1.1\\r\\nHost: localho\"..., 16400, 0, NULL, NULL) = 80\n</code></pre>","path":["如何对 Sōzu 进行基准测试/观察"],"tags":[]},{"location":"benchmark/#_3","level":3,"title":"找出代码的哪些部分导致了系统调用","text":"<p>对于这种挖掘，Sōzu 必须在调试模式下运行，即： 没有使用 <code>--release</code> 标志编译。执行：</p> <pre><code>cargo run -- --config my-config.toml start\n</code></pre> <p>如上所述找到 pid，然后执行：</p> <pre><code>strace --attach=14157 --stack-traces\n# or\nstrace -p 14157 -k\n</code></pre> <p>curl Sōzu 一次，例如</p> <pre><code>curl http://localhost:8080/api  -v\n</code></pre> <p>现在你可以看到每个系统调用是由哪段代码负责的。 例如，以下是负责在文件描述符为 12 的套接字上进行 <code>connect</code> 系统调用的代码。 我们可以看到它是一个 HTTP 会话连接到其后端：</p> <pre><code>connect(12, {sa_family=AF_INET, sin_port=htons(1052), sin_addr=inet_addr(\"127.0.0.1\")}, 16) = -1 EINPROGRESS (Operation now in progress)\n &gt; /usr/lib/libc.so.6(__connect+0x14) [0x112454]\n &gt; /path/to/sozu/target/debug/sozu(mio::sys::unix::tcp::connect+0x84) [0x17b2ec4]\n &gt; /path/to/sozu/target/debug/sozu(mio::net::tcp::stream::TcpStream::connect+0x127) [0x17ad9e7]\n &gt; /path/to/sozu/target/debug/sozu(sozu_lib::backends::Backend::try_connect+0x88) [0xb03898]\n &gt; /path/to/sozu/target/debug/sozu(sozu_lib::backends::BackendMap::backend_from_cluster_id+0x465) [0xb04145]\n &gt; /path/to/sozu/target/debug/sozu(sozu_lib::protocol::kawa_h1::Http&lt;Front,L&gt;::get_backend_for_sticky_session+0x5ab) [0xca8beb]\n &gt; /path/to/sozu/target/debug/sozu(sozu_lib::protocol::kawa_h1::Http&lt;Front,L&gt;::backend_from_request+0x159) [0xca69b9]\n &gt; /path/to/sozu/target/debug/sozu(sozu_lib::protocol::kawa_h1::Http&lt;Front,L&gt;::connect_to_backend+0xb7a) [0xcaafba]\n &gt; /path/to/sozu/target/debug/sozu(sozu_lib::protocol::kawa_h1::Http&lt;Front,L&gt;::ready_inner+0x423) [0xcaf3a3]\n &gt; /path/to/sozu/target/debug/sozu(&lt;sozu_lib::protocol::kawa_h1::Http&lt;Front,L&gt; as sozu_lib::protocol::SessionState&gt;::ready+0x2d) [0xcb040d]\n &gt; /path/to/sozu/target/debug/sozu(&lt;sozu_lib::http::HttpStateMachine as sozu_lib::protocol::SessionState&gt;::ready+0xf2) [0xdbb9b2]\n &gt; /path/to/sozu/target/debug/sozu(&lt;sozu_lib::http::HttpSession as sozu_lib::ProxySession&gt;::ready+0x114) [0xdb4b54]\n &gt; /path/to/sozu/target/debug/sozu(sozu_lib::server::Server::ready+0x746) [0xc95846]\n &gt; /path/to/sozu/target/debug/sozu(sozu_lib::server::Server::run+0x66d) [0xc8869d]\n &gt; /path/to/sozu/target/debug/sozu(sozu::worker::begin_worker_process+0x3060) [0x32e480]\n &gt; /path/to/sozu/target/debug/sozu(sozu::main+0x42e) [0x556afe]\n &gt; /path/to/sozu/target/debug/sozu(core::ops::function::FnOnce::call_once+0xb) [0x1e453b]\n &gt; /path/to/sozu/target/debug/sozu(std::sys_common::backtrace::__rust_begin_short_backtrace+0xe) [0x287e6e]\n &gt; /path/to/sozu/target/debug/sozu(std::rt::lang_start::{{closure}}+0x11) [0x2ff2e1]\n &gt; /path/to/sozu/target/debug/sozu(std::rt::lang_start_internal+0x42e) [0x18217fe]\n &gt; /path/to/sozu/target/debug/sozu(std::rt::lang_start+0x3a) [0x2ff2ba]\n &gt; /path/to/sozu/target/debug/sozu(main+0x1e) [0x556f6e]\n &gt; /usr/lib/libc.so.6(__libc_init_first+0x90) [0x27cd0]\n &gt; /usr/lib/libc.so.6(__libc_start_main+0x8a) [0x27d8a]\n &gt; /path/to/sozu/target/debug/sozu(_start+0x25) [0x17bca5]\n</code></pre>","path":["如何对 Sōzu 进行基准测试/观察"],"tags":[]},{"location":"configure/","level":1,"title":"配置 Sōzu","text":"<p>在深入了解代理的配置部分之前，如果您还没有阅读 入门文档，建议您先阅读一下。</p>","path":["配置 Sōzu"],"tags":[]},{"location":"configure/#_1","level":2,"title":"配置文件","text":"<p>配置文件使用 .toml 格式。</p> <p>Sōzu 配置过程涉及 3 个主要参数来源：</p> <ul> <li><code>global</code> 部分，用于设置进程范围的参数。</li> <li><code>https</code>、<code>http</code>、<code>tcp</code> 等协议的定义。</li> <li><code>[clusters]</code>下的集群部分。</li> </ul>","path":["配置 Sōzu"],"tags":[]},{"location":"configure/#_2","level":3,"title":"全局参数","text":"<p>全局部分中的参数允许您定义主进程和工作进程共享的全局设置（例如日志级别）：</p> 参数 描述 可能的值 <code>saved_state</code> sozu 启动时尝试加载其状态的路径 <code>log_level</code> 可能的值为 <code>debug</code>、<code>trace</code>、<code>error</code>、<code>warn</code>、<code>info</code> <code>log_target</code> 可能的值为 <code>stdout, tcp or udp address</code> <code>access_logs_target</code> 可能的值为（如果激活，则将访问日志发送到单独的目标） <code>stdout</code>、<code>tcp</code> 或 <code>udp address</code> <code>command_socket</code> unix 命令套接字的路径 <code>command_buffer_size</code> 主进程用于处理命令的缓冲区大小（以字节为单位）。 <code>max_command_buffer_size</code> 主进程用于处理命令的缓冲区的最大大小。 <code>worker_count</code> 工作进程数 <code>worker_automatic_restart</code> 如果激活，则重新启动出现紧急情况或崩溃的工作进程（默认激活） <code>handle_process_affinity</code> 将工作进程绑定到 cpu 内核。 <code>max_connections</code> 最大同时/打开的连接数 <code>max_buffers</code> 用于代理的最大缓冲区数 <code>min_buffers</code> 为代理预分配的最小缓冲区数 <code>buffer_size</code> 工作进程使用的请求缓冲区大小（以字节为单位） <code>ctl_command_timeout</code> 命令行等待命令完成的最长时间 <code>pid_file_path</code> 将 pid 存储在特定文件位置 <code>front_timeout</code> 前端套接字的最长不活动时间 <code>connect_timeout</code> 请求连接的最长不活动时间 <code>request_timeout</code> 请求的最长不活动时间 <code>zombie_check_interval</code> 僵尸会话检查之间的持续时间 <code>activate_listeners</code> 自动启动监听器 <p>示例：</p> <pre><code>command_socket = \"./command_folder/sock\"\nsaved_state = \"./state.json\"\nlog_level = \"info\"\nlog_target = \"stdout\"\ncommand_buffer_size = 16384\nworker_count = 2\nhandle_process_affinity = false\nmax_connections = 500\nmax_buffers = 500\nbuffer_size = 16384\nactivate_listeners = true\n</code></pre>","path":["配置 Sōzu"],"tags":[]},{"location":"configure/#_3","level":3,"title":"监听器","text":"<p>listener 部分描述了一组接受客户端连接的侦听套接字。 您可以根据需要定义任意数量的侦听器。 它们遵循以下格式：</p> <p>通用参数：</p> <pre><code>[[listeners]]\n# 可能的值是 http、https 或 tcp\nprotocol = \"http\"\n# 监听地址\naddress = \"0.0.0.0:8080\"\n# address = \"[::]:8080\"\n\n# 为日志和转发的标头指定一个不同于套接字所见的 IP\n# public_address = \"1.2.3.4:80\n\n# 配置客户端套接字以接收 PROXY 协议标头\n# expect_proxy = false\n</code></pre>","path":["配置 Sōzu"],"tags":[]},{"location":"configure/#http-https","level":4,"title":"HTTP 和 HTTPS 侦听器的特定选项","text":"<p>从 1.0.0 版本开始，Sōzu 允许为 HTTP 和 HTTPS 侦听器定义自定义 HTTP 应答。</p> <p>这些应答是可定制的：</p> <ul> <li>301 永久移动</li> <li>400 错误请求</li> <li>401 未经授权</li> <li>404 未找到</li> <li>408 请求超时</li> <li>413 负载过大</li> <li>502 错误网关</li> <li>503 服务不可用</li> <li>504 网关超时</li> <li>507 存储空间不足</li> </ul> <p>这些应答应以任何扩展名的纯文本文件提供（为清晰起见，我们建议使用 <code>.http</code>）， 并且可能如下所示：</p> <pre><code>HTTP/1.1 404 Not Found\nCache-Control: no-cache\nConnection: close\nSozu-Id: %REQUEST_ID\n\n&lt;style&gt;pre{background:#EEE;padding:10px;border:1px solid #AAA;border-radius: 5px;}&lt;/style&gt;\n&lt;h1&gt;404 Not Found&lt;/h1&gt;\n\n&lt;p&gt;在此处插入您的自定义文本，实际上，所有 HTML 都是可更改的，包括 CSS。&lt;/p&gt;\n\n&lt;pre&gt;\n{\n    \"route\": \"%ROUTE\",\n    \"request_id\": \"%REQUEST_ID\",\n}\n&lt;/pre&gt;\n&lt;footer&gt;这是 Sozu 的自动应答。&lt;/footer&gt;\",\n</code></pre> <p>有许多可用的模板变量，例如 <code>REQUEST_ID</code> 或 <code>CLUSTER_ID</code>， 在生成错误时，代理逻辑将替换它们。</p> <p>要创建您自己的自定义 HTTP 应答，我们强烈建议您首先复制 <code>lib/src/protocol/kawa_h1/answers.rs</code> 中存在的默认应答，然后根据自己的喜好进行更改。 为清晰起见，请随时删除默认字符串的 <code>\\r</code> 换行符。 Sōzu 将解析您的文件并替换您使用的任何换行符。</p> <p>然后，对于每个侦听器，提供每个自定义应答的绝对路径。</p> <pre><code># 当 sozu 不知道请求的域或路径时，将发送 404 响应\nanswer_404 = \"/path/to/my-404-answer.http\"\n# 如果没有可用的后端服务器，则发送 503 响应\nanswer_503 = \"/path/to/my-503-answer.http\"\n# answer_507 = ...\n</code></pre> <p>如果前端具有 <code>sticky_session</code>，则粘性名称在侦听器级别定义。</p> <pre><code># 定义粘性会话 cookie 的名称，如果 `sticky_session` 被激活\n# a cluster。默认为“SOZUBALANCEID”\nsticky_name = \"SOZUBALANCEID\"\n</code></pre>","path":["配置 Sōzu"],"tags":[]},{"location":"configure/#https","level":4,"title":"HTTPS 侦听器的特定选项","text":"<pre><code># 支持的 TLS 版本。可能的值为“SSL_V2”、“SSL_V3”、\n# “TLS_V12”、“TLS_V13”。默认为“TLS_V12”和“TLS_V13”\ntls_versions = [\"TLS_V12\", \"TLS_V13\"]\n</code></pre>","path":["配置 Sōzu"],"tags":[]},{"location":"configure/#rustls-https","level":4,"title":"基于 Rustls 的 HTTPS 侦听器的特定选项","text":"<pre><code># 基于 rustls 的 HTTPS 侦听器的特定选项\ncipher_list = [\n    # TLS 1.3 密码套件\n    \"TLS13_AES_256_GCM_SHA384\",\n    \"TLS13_AES_128_GCM_SHA256\",\n    \"TLS13_CHACHA20_POLY1305_SHA256\",\n    # TLS 1.2 密码套件\n    \"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\",\n    \"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\",\n    \"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\",\n    \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\",\n    \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\",\n    \"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\",\n]\n</code></pre>","path":["配置 Sōzu"],"tags":[]},{"location":"configure/#_4","level":3,"title":"集群","text":"<p>您可以在 <code>[clusters]</code> 部分下声明您的 clusters 列表。 它们遵循以下格式：</p> <p>强制参数：</p> <pre><code>[clusters]\n\n[clusters.NameOfYourCluster]\n# 可能的值是 http 或 tcp\n# https 代理将在此处使用 http\nprotocol = \"http\"\n\n# 每个集群的负载均衡算法。可能的值是\n# “roundrobin”和“random”。默认为“roundrobin”\n# load_balancing_policy=\"roundrobin\"\n\n# 强制集群将 http 流量重定向到 https\n# https_redirect = true\n\nfrontends = [\n  { address = \"0.0.0.0:8080\", hostname = \"lolcatho.st\" },\n  { address = \"0.0.0.0:8443\", hostname = \"lolcatho.st\", certificate = \"../lib/assets/certificate.pem\", key = \"../lib/assets/key.pem\", certificate_chain = \"../lib/assets/certificate_chain.pem\" }\n]\n# 前端的其他选项：sticky_session（布尔值）\n\nbackends  = [\n  { address = \"127.0.0.1:1026\" }\n]\n</code></pre>","path":["配置 Sōzu"],"tags":[]},{"location":"configure/#_5","level":2,"title":"指标","text":"<p>Sōzu 通过 <code>UDP</code> 套接字向另一个网络组件报告其自身状态。 主进程和工作进程负责发送其状态。 我们实现 statsd 协议以发送统计信息。 然后，任何理解 <code>statsd</code> 协议的服务都可以从 Sōzu 收集指标。</p>","path":["配置 Sōzu"],"tags":[]},{"location":"configure/#_6","level":3,"title":"配置指标","text":"<p>在您的 <code>config.toml</code> 中，您可以通过添加以下内容来定义外部服务的地址和端口：</p> <pre><code>[metrics]\naddress = \"127.0.0.1:8125\"\n# 使用 InfluxDB 的 statsd 协议风格添加标签\n# tagged_metrics = false\n# 指标键前缀\n# prefix = \"sozu\"\n</code></pre> <p>目前，我们无法更改发送消息的频率。</p>","path":["配置 Sōzu"],"tags":[]},{"location":"configure/#_7","level":3,"title":"外部服务示例","text":"<ul> <li>statsd</li> <li>grad</li> </ul>","path":["配置 Sōzu"],"tags":[]},{"location":"configure/#proxy","level":2,"title":"PROXY 协议","text":"<p>当网络流通过代理时，后端服务器只能看到代理用作客户端地址的 IP 地址和端口。 真正的源 IP 地址和端口只能被代理看到。 由于此信息对于日志记录、安全性等很有用， 因此开发了 PROXY 协议 以将其传输到后端服务器。 使用此协议，在连接到后端服务器后，代理将首先发送一个小的标头，指示客户端 IP 地址和端口， 以及代理的接收 IP 地址和端口，然后将发送来自客户端的流。</p> <p>Sōzu 在三种配置中支持 version 2 of the <code>PROXY protocol</code>：</p> <ul> <li>“send”协议：Sōzu，在 TCP 代理模式下，会将标头发送到后端服务器</li> <li>“expect”协议：Sōzu 从代理接收标头，为其自身的日志记录和指标解释它，并在 HTTP 转发标头中使用它</li> <li>“relay”协议：Sōzu，在 TCP 代理模式下，可以接收标头，并将其传输到后端服务器</li> </ul> <p>更多信息在这里：proxy-protocol spec</p>","path":["配置 Sōzu"],"tags":[]},{"location":"configure/#sozu-expect-proxy","level":3,"title":"配置 Sōzu 以 expect PROXY 协议标头","text":"<p>在从套接字读取客户端发送的任何字节之前，配置面向客户端的连接以接收 PROXY 协议标头。</p> <pre><code>                           发送 PROXY                    期望 PROXY\n                           协议头                        协议头\n    +--------+\n    | 客户端 |\n    |        |             +---------+                   +------------+      +-----------+\n    +--------+  ---------&gt; | 代理    |                   | Sozu       |      | 上游      |\n   /        /              |         |  ---------------&gt; |            |------| 服务器    |\n  /________/               +---------+                   +------------+      +-----------+\n</code></pre> <p>它受 HTTP、HTTPS 和 TCP 代理支持。</p> <p>配置：</p> <pre><code>[[listeners]]\naddress = \"0.0.0.0:80\"\nexpect_proxy = true\n</code></pre>","path":["配置 Sōzu"],"tags":[]},{"location":"configure/#sozu-proxy","level":3,"title":"将 Sōzu 配置为向 上游后端 发送 PROXY 协议标头","text":"<p>通过建立到集群中声明的后端的任何连接发送 PROXY 协议标头。</p> <pre><code>                           发送 PROXY\n    +--------+             协议头\n    | 客户端 |             +---------+\n    |        |             | Sozu    |                +-----------------+\n    +--------+  ---------&gt; |         |  ------------&gt; | 代理/上游       |\n   /        /              |         |                | 服务器          |\n  /________/               +---------+                +-----------------+\n</code></pre> <p>配置：</p> <pre><code>[[listeners]]\naddress = \"0.0.0.0:81\"\n\n[clusters]\n[clusters.NameOfYourTcpCluster]\nsend_proxy = true\nfrontends = [\n  { address = \"0.0.0.0:81\" }\n]\n</code></pre> <p>注意：仅适用于 TCP 集群（HTTP 和 HTTPS 代理将使用转发标头）。</p>","path":["配置 Sōzu"],"tags":[]},{"location":"configure/#sozu-proxy_1","level":3,"title":"配置 Sōzu 以将 PROXY 协议标头 中继 到上游","text":"<p>Sōzu 将从客户端连接接收 PROXY 协议标头，检查其有效性，然后将其转发到上游后端。这允许反向代理链而不会丢失客户端连接信息。</p> <pre><code>                           发送 PROXY                       期望 PROXY               发送 PROXY\n                           协议头                           协议头                     协议头\n    +--------+\n    | 客户端 |\n    |        |             +---------+                      +------------+             +-------------------+\n    +--------+  +--------&gt; | 代理    |                      | Sozu       |             | 代理/上游         |\n   /        /              |         |                      |            | +---------&gt; | 服务器            |\n  /________/               +---------+                      +------------+             +-------------------+\n</code></pre> <p>配置：</p> <p>这仅涉及 TCP 集群（HTTP 和 HTTPS 代理可以直接在 expect 模式下工作，并将使用转发标头）。</p> <pre><code>[[listeners]]\naddress = \"0.0.0.0:80\"\nexpect_proxy = true\n\n[clusters]\n\n[clusters.NameOfYourCluster]\nsend_proxy = true\nfrontends = [\n  { address = \"0.0.0.0:80\" }\n]\n</code></pre>","path":["配置 Sōzu"],"tags":[]},{"location":"configure_cli/","level":1,"title":"通过命令行配置 sozu","text":"<p>sozu 可执行文件可用于启动代理并对其进行配置：添加新的后端服务器、读取指标等。 它通过 unix 套接字与当前正在运行的代理进行通信。</p> <p>您可以通过将以下内容添加到您的 <code>config.toml</code> 来指定其路径：</p> <pre><code>command_socket = \"path/to/your/command_folder/sock\"\n</code></pre>","path":["通过命令行配置 sozu"],"tags":[]},{"location":"configure_cli/#http-https","level":2,"title":"添加具有 http 和 https 前端的集群","text":"<p>首先，您需要创建一个具有 id 和负载平衡策略（roundrobin 或 random）的新集群：</p> <pre><code>sozu --config /etc/sozu/config.toml cluster add --id &lt;my_cluster_id&gt; --load-balancing-policy roundrobin\n</code></pre> <p>它不会显示任何内容，但您可以通过查询 sozu 来验证集群是否已成功添加：</p> <pre><code>sozu --config /etc/sozu/config.toml query clusters\n</code></pre> <p>然后你需要添加一个后端：</p> <pre><code>sozu --config /etc/sozu/config.toml backend add --address 127.0.0.1:3000 --backend-id &lt;my_backend_id&gt; --id &lt;my_cluster_id&gt;\n</code></pre>","path":["通过命令行配置 sozu"],"tags":[]},{"location":"configure_cli/#http","level":3,"title":"添加 http 前端","text":"<p>和一个 http 监听器：</p> <pre><code>sozu --config /etc/sozu/config.toml listener http add --address 0.0.0.0:80 --tls-versions TLSv1.2 --tls-cipher-list ECDHE-ECDSA-AES256-GCM-SHA384 --tls-cipher-suites TLS_AES_256_GCM_SHA384 --tls-signature-algorithms ECDSA+SHA512 --tls-groups-list x25519 --expect-proxy\n</code></pre> <p>最后，您必须创建一个前端以允许 sozu 将流量从侦听器发送到您的后端：</p> <pre><code>sozu --config /etc/sozu/config.toml frontend http add --address 0.0.0.0:80 --hostname &lt;my_cluster_hostname&gt; id &lt;my_cluster_id&gt;\n</code></pre>","path":["通过命令行配置 sozu"],"tags":[]},{"location":"configure_cli/#https","level":3,"title":"添加 https 前端","text":"<p>和一个 https 监听器：</p> <pre><code>sozu --config /etc/sozu/config.toml listener https add --address 0.0.0.0:443\n</code></pre> <p>最后，您必须创建一个前端以允许 sozu 将流量从侦听器发送到您的后端：</p> <pre><code>sozu --config /etc/sozu/config.toml frontend https add --address 0.0.0.0:443 --hostname &lt;my_cluster_hostname&gt; id &lt;my_cluster_id&gt;\n</code></pre>","path":["通过命令行配置 sozu"],"tags":[]},{"location":"configure_cli/#sozu_1","level":2,"title":"检查 sozu 的状态","text":"<p>它显示了一个工作进程列表并显示有关其状态的信息。</p> <pre><code>sozu --config /etc/sozu/config.toml status\n</code></pre>","path":["通过命令行配置 sozu"],"tags":[]},{"location":"configure_cli/#_1","level":2,"title":"获取指标和统计信息","text":"<p>它将显示有关 sozu、工作进程和集群指标的全局统计信息。</p> <pre><code>sozu --config /etc/sozu/config.toml query metrics\n</code></pre>","path":["通过命令行配置 sozu"],"tags":[]},{"location":"configure_cli/#_2","level":2,"title":"转储和恢复状态","text":"<p>如果 sozu 配置（集群、前端和后端）未写入配置文件，您可以保存 sozu 状态以便稍后恢复。</p> <pre><code>sozu --config /etc/sozu/config.toml state save --file state.json\n</code></pre> <p>然后正常关闭 sozu：</p> <pre><code>sozu --config /etc/sozu/config.toml shutdown\n</code></pre> <p>重新启动 sozu 并恢复其状态：</p> <pre><code>sozu --config /etc/sozu/config.toml state load --file state.json\n</code></pre> <p>您应该能够像关闭前一样请求您的集群。</p>","path":["通过命令行配置 sozu"],"tags":[]},{"location":"configure_cli/#_3","level":3,"title":"使用事件监控后端状态","text":"<p>此 CLI 命令：</p> <pre><code>sozu --config /path/to/config.toml events\n</code></pre> <p>侦听 Sōzu 工作进程在后端关闭、再次启动或没有可用后端时发送的事件。</p>","path":["通过命令行配置 sozu"],"tags":[]},{"location":"debugging_strategies/","level":1,"title":"如何调试 sozu","text":"<p>Sozu 提供日志和指标，可以检测大多数生产问题。</p>","path":["如何调试 sozu"],"tags":[]},{"location":"debugging_strategies/#_1","level":2,"title":"收集信息","text":"","path":["如何调试 sozu"],"tags":[]},{"location":"debugging_strategies/#sozu_1","level":3,"title":"通过 sozu 命令行转储状态","text":"<p>在生产系统中收集有关配置状态的信息非常有用。 以下是一些可用于获取当前状态快照的命令：</p> <pre><code>sozu -c /etc/config.toml status\"\nsozu -c /etc/config.toml metrics get\"\nsozu -c /etc/config.toml clusters list\"\nsozu -c /etc/config.toml state save -f \"sozu-state-$(date -Iseconds).txt\"\n</code></pre>","path":["如何调试 sozu"],"tags":[]},{"location":"debugging_strategies/#_2","level":3,"title":"日志记录","text":"<p>有三个与日志记录相关的配置选项：</p> <ul> <li><code>log_level</code>: 设置日志记录详细程度</li> <li><code>log_target</code>: 日志发送到哪里。它可以具有以下格式：</li> <li><code>stdout</code></li> <li><code>udp://127.0.0.1:9876</code></li> <li><code>tcp://127.0.0.1:9876</code></li> <li><code>unix:///var/sozu/logs</code></li> <li><code>file:///var/logs/sozu.log</code></li> <li><code>access_logs_target</code>: 如果激活，则将访问日志发送到单独的目的地</li> </ul> <p><code>log_level</code> 遵循 env_logger 的级别指令。 此外，<code>RUST_LOG</code> 环境变量可用于覆盖日志级别。</p> <p>如果 sozu 是在发布模式下构建的，则 <code>DEBUG</code> 和 <code>TRACE</code> 日志级别不会被编译进去， 除非您设置了编译功能 <code>logs-debug</code> 和 <code>logs-trace</code>。</p>","path":["如何调试 sozu"],"tags":[]},{"location":"debugging_strategies/#_3","level":3,"title":"指标","text":"<p>sozu 运行时会生成各种指标。可以通过两种方式访问它们：</p> <ul> <li>通过 <code>sozu metrics get</code>，它将显示主进程和工作进程的指标。每次调用之间都会刷新计数器</li> <li>通过 UDP，遵循 statsd 协议（可选地支持 InfluxDB 的标签）</li> </ul> <p>以下是在配置文件中使用 statsd 设置指标的方法：</p> <pre><code>[metrics]\naddress = \"127.0.0.1:8125\"\n# 使用 InfluxDB 的 statsd 协议风格添加标签（默认值：false）\ntagged_metrics = true\n# 指标键前缀（默认值：sozu）\n# prefix = \"sozu\"\n</code></pre>","path":["如何调试 sozu"],"tags":[]},{"location":"debugging_strategies/#_4","level":2,"title":"要关注的图表和指标","text":"<p>（假设我们将 <code>sozu</code> 设置为指标前缀）</p>","path":["如何调试 sozu"],"tags":[]},{"location":"debugging_strategies/#_5","level":3,"title":"跟踪有效流量","text":"","path":["如何调试 sozu"],"tags":[]},{"location":"debugging_strategies/#_6","level":4,"title":"访问日志","text":"<p>访问日志具有以下格式：</p> <pre><code>2018-09-21T14:01:51Z 821136800672570 71013 WRK-00 INFO  450b071a-53b8-4fd7-b2f2-1213f03ef032 MyCluster      127.0.0.1:52323 -&gt; 127.0.0.1:1027       241ms 855μs 560 33084   200 OK lolcatho.st:8080 GET /\n</code></pre> <p>从左到右：</p> <ul> <li>ISO8601 格式的日期，UTC 时区</li> <li>单调时钟（以防某些消息以错误的顺序出现）</li> <li>PID</li> <li>工作进程名称（主进程为“MAIN”）</li> <li>日志级别</li> <li>请求 ID（UUID，为每个请求随机生成，如果在 keep-alive 中执行多个请求，则在同一连接上更改）</li> <li>集群 ID</li> <li>客户端的源 IP 和端口</li> <li>后端服务器的目标 IP 和端口</li> <li>响应时间（从客户端收到第一个字节到发送给客户端的最后一个字节）</li> <li>服务时间（sozu 处理会话所花费的时间）</li> <li>上传的字节数</li> <li>下载的字节数</li> </ul>","path":["如何调试 sozu"],"tags":[]},{"location":"debugging_strategies/#http","level":4,"title":"HTTP 状态指标","text":"<p>以下指标跟踪已正确发送到后端服务器的请求：</p> <ul> <li><code>sozu.http.status.1xx</code>：计算状态为 100 到 199 的请求</li> <li><code>sozu.http.status.2xx</code>：计算状态为 200 到 299 的请求</li> <li><code>sozu.http.status.3xx</code>：计算状态为 300 到 399 的请求</li> <li><code>sozu.http.status.4xx</code>：计算状态为 400 到 499 的请求</li> <li><code>sozu.http.status.5xx</code>：计算状态为 500 到 599 的请求</li> <li><code>sozu.http.requests</code>：每个请求递增（上述计数器的总和）</li> </ul>","path":["如何调试 sozu"],"tags":[]},{"location":"debugging_strategies/#_7","level":4,"title":"传输的数据","text":"<p>有全局的 <code>sozu.bytes_in</code> 和 <code>sozu.bytes_out</code> 指标，用于计算 sozu 的前端流量。 这些指标也可以具有后端 ID 和集群 ID。然后它们将指示 从后端服务器的角度来看的输入和输出字节。</p>","path":["如何调试 sozu"],"tags":[]},{"location":"debugging_strategies/#_8","level":4,"title":"响应时间","text":"<p>?</p>","path":["如何调试 sozu"],"tags":[]},{"location":"debugging_strategies/#_9","level":4,"title":"协议","text":"<p>客户端会话可以处于其网络协议的各种状态。例如，一个连接 可以从“期望代理协议”（假设前面有一个 TCP 代理）到 TLS 握手， 到 HTTPS，再到 WSS（基于 TLS 的 websocket）。</p> <p>您可以跟踪以下仪表，以指示当前的协议使用情况：</p> <ul> <li><code>sozu.protocol.proxy.expect</code></li> <li><code>sozu.protocol.proxy.send</code></li> <li><code>sozu.protocol.proxy.relay</code></li> <li><code>sozu.protocol.tcp</code></li> <li><code>sozu.protocol.tls.handshake</code></li> <li><code>sozu.protocol.http</code></li> <li><code>sozu.protocol.https</code></li> <li><code>sozu.protocol.ws</code></li> <li><code>sozu.protocol.wss</code></li> </ul>","path":["如何调试 sozu"],"tags":[]},{"location":"debugging_strategies/#_10","level":3,"title":"跟踪失败的请求","text":"<p>Sozu 有一种以最少的资源使用来响应无效流量的方法，即发送预定义的答案。 它对无效流量（不符合标准）和路由问题（未知主机和/或路径， 无响应的后端服务器）执行此操作。</p> <p><code>sozu.http.errors</code> 计数器是失败请求的总和。它包含以下内容：</p> <ul> <li><code>sozu.http.frontend_parse_errors</code>: sozu 收到了一些无效的流量</li> <li><code>sozu.http.400.errors</code>: 无法解析主机名</li> <li><code>sozu.http.404.errors</code>: 未知主机名和/或路径</li> <li><code>sozu.http.413.errors</code>: 请求过大</li> <li><code>sozu.http.503.errors</code>: 无法连接到后端服务器，或者相应集群没有可用的后端服务器</li> </ul> <p>更进一步，后端连接问题由以下指标跟踪：</p> <ul> <li><code>sozu.backend.connections.error</code>: 无法连接到后端服务器</li> <li><code>sozu.backend.down</code>: 重试策略已触发并将后端服务器标记为关闭</li> </ul> <p>在请求发回 503 错误后，<code>sozu.http.503.errors</code> 指标会递增，并且在断路器触发后（我们等待 3 次到后端服务器的失败连接），会发送 503 错误。</p> <p>后端连接错误将导致以下日志消息：</p> <pre><code>2018-09-21T14:36:08Z 823194694977734 71501 WRK-00 ERROR 839f592b-a194-4c3b-848b-8ef024129969    MyCluster    error connecting to backend, trying again\n</code></pre> <p>断路器触发会将此写入日志：</p> <pre><code>2018-09-21T14:36:57Z 823243245414405 71524 WRK-00 ERROR 7029d66e-57a8-406e-ae61-e4bf9ff7b6b8    MyCluster    max connection attempt reached\n</code></pre> <p>将后端服务器标记为关闭的重试策略将写入以下日志消息：</p> <pre><code>2018-09-21T14:37:31Z 823277868708804 71524 WRK-00 ERROR no more available backends for cluster MyCluster\n</code></pre>","path":["如何调试 sozu"],"tags":[]},{"location":"debugging_strategies/#_11","level":3,"title":"可伸缩性","text":"<p>Sozu 精细地处理其资源使用，并对请求数量 或内存使用设置硬性限制。</p> <p>要跟踪连接，请遵循以下仪表：</p> <ul> <li><code>sozu.client.connections</code> 用于前端连接</li> <li><code>sozu.backend.connections</code> 用于后端连接</li> <li><code>sozu.http.active_requests</code> 用于当前活动连接（等待 下一个请求的 keep-alive 连接被标记为不活动）</li> </ul> <p>客户端连接应始终高于后端连接，而后端连接应高于 活动请求（非活动会话可以保持后端连接）。</p> <p>这些指标与资源使用密切相关，资源使用由以下各项跟踪：</p> <ul> <li><code>sozu.slab.entries</code>: slab 分配器中使用的插槽数。通常，每个侦听器套接字有一个插槽， 一个用于连接到主进程，一个用于指标套接字，然后每个前端连接一个， 每个后端连接一个。因此，连接数应始终接近（但低于）slab 计数。</li> <li><code>sozu.buffer.number</code>: 缓冲池中使用的缓冲区数。非活动会话和我们发送 默认答案（400、404、413、503 HTTP 错误）的请求不使用缓冲区。活动 HTTP 会话使用一个缓冲区（流水线模式除外）， WebSocket 会话使用两个缓冲区。因此，缓冲区数应始终低于 slab 计数，并且低于连接数。</li> <li><code>sozu.zombies</code>: sozu 集成了一个僵尸会话检查器。如果某个会话一段时间内没有任何操作， 则事件循环或协议实现中可能存在错误，因此会记录其内部状态。对于每个被删除的僵尸会话，此计数器都会递增。</li> </ul> <p>新连接被放入队列中，并等待直到创建会话（如果我们有可用资源）， 或直到配置的超时已过。以下指标观察接受队列的使用情况：</p> <ul> <li><code>sozu.accept_queue.connections</code>: 接受队列中的套接字数</li> <li><code>sozu.accept_queue.timeout</code>: 每当套接字在队列中停留时间过长并被关闭时递增</li> <li><code>sozu.accept_queue.wait_time</code>: 每当创建会话时，此指标记录套接字在接受队列中必须等待多长时间</li> </ul>","path":["如何调试 sozu"],"tags":[]},{"location":"debugging_strategies/#tls","level":3,"title":"TLS 特定信息","text":"<p>TLS 版本计数器：</p> <ul> <li><code>sozu.tls.version.SSLv2</code></li> <li><code>sozu.tls.version.SSLv3</code></li> <li><code>sozu.tls.version.TLSv1_0</code></li> <li><code>sozu.tls.version.TLSv1_1</code></li> <li><code>sozu.tls.version.TLSv1_2</code></li> <li><code>sozu.tls.version.TLSv1_3</code></li> <li><code>sozu.tls.version.Unknown</code></li> </ul> <p>Rustls 特定，协商的密码套件：</p> <ul> <li><code>sozu.tls.cipher.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256</code></li> <li><code>sozu.tls.cipher.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256</code></li> <li><code>sozu.tls.cipher.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</code></li> <li><code>sozu.tls.cipher.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384</code></li> <li><code>sozu.tls.cipher.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256</code></li> <li><code>sozu.tls.cipher.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384</code></li> <li><code>sozu.tls.cipher.TLS13_CHACHA20_POLY1305_SHA256</code></li> <li><code>sozu.tls.cipher.TLS13_AES_256_GCM_SHA384</code></li> <li><code>sozu.tls.cipher.TLS13_AES_128_GCM_SHA256</code></li> <li><code>sozu.tls.cipher.Unsupported</code></li> </ul>","path":["如何调试 sozu"],"tags":[]},{"location":"debugging_strategies/#_12","level":2,"title":"典型错误场景","text":"","path":["如何调试 sozu"],"tags":[]},{"location":"debugging_strategies/#_13","level":3,"title":"路由问题","text":"<p>正常流量（<code>sozu.http.requests</code>）下降，而 404（<code>sozu.http.404.errors</code>）和 503（<code>sozu.http.503.errors</code>）增加，这意味着 sozu 的配置可能无效。 使用以下命令检查配置状态：</p> <pre><code>sozu -c /etc/config.toml clusters list\n</code></pre> <p>并且，对于特定集群 ID 的完整配置：</p> <pre><code>sozu -c /etc/config.toml clusters list -i cluster_id\n</code></pre>","path":["如何调试 sozu"],"tags":[]},{"location":"debugging_strategies/#_14","level":3,"title":"后端服务器不可用","text":"<p><code>sozu.http.503.errors</code> 增加，大量的 <code>sozu.backend.connections.error</code> 和 <code>sozu.backend.down</code> 记录：后端服务器已关闭。 检查日志中是否有 <code>error connecting to backend, trying again</code> 和 <code>no more available backends for cluster &lt;cluster_id&gt;</code> 以找出受影响的集群</p>","path":["如何调试 sozu"],"tags":[]},{"location":"debugging_strategies/#_15","level":3,"title":"僵尸","text":"<p>如果 <code>sozu.zombies</code> 指标触发，这意味着存在事件循环或协议实现 错误。日志应包含被终止的会话的内部状态。请复制这些 日志并向 sozu 提交问题。</p> <p>它通常伴随着 <code>sozu.slab.entries</code> 增加，而连接数或活动请求数保持 不变。当僵尸检查器激活时，slab 计数将下降。</p>","path":["如何调试 sozu"],"tags":[]},{"location":"debugging_strategies/#_16","level":3,"title":"无效的会话关闭","text":"<p>如果 slab 计数和活动请求保持不变，但 <code>sozu.client.connections</code> 和/或 <code>sozu.backend.connections</code> 正在增加，这意味着会话没有被 sozu 正确关闭，请为此提交一个问题。 （如果 slab 计数保持不变，套接字仍应正确关闭）</p>","path":["如何调试 sozu"],"tags":[]},{"location":"debugging_strategies/#_17","level":3,"title":"接受队列正在填满","text":"<p>如果 <code>sozu.accept_queue.connections</code> 正在增加，这意味着接受队列正在填满，因为 sozu 处于 高负载下（在健康负载下，此队列几乎总是空的）。<code>sozu.accept_queue.wait_time</code> 也应该增加。 如果 <code>sozu.accept_queue.timeout</code> 大于零，sozu 无法足够快地接受会话并且 正在拒绝流量。</p>","path":["如何调试 sozu"],"tags":[]},{"location":"debugging_strategies/#_18","level":2,"title":"开发期间","text":"<p>在 config.toml 文件中：</p> <ul> <li>如果错误只影响其中一个协议（HTTP、HTTPS 或 TCP），请停用其他协议</li> <li>将 <code>worker_count</code> 设置为 1 以避免日志中出现重复</li> <li>调试紧急情况：</li> <li>使用 <code>RUST_BACKTRACE=1</code> 启动 sozu</li> <li>将 <code>worker_automatic_restart</code> 设置为 false（以便 sozu 可以立即停止）</li> </ul>","path":["如何调试 sozu"],"tags":[]},{"location":"debugging_strategies/#_19","level":3,"title":"跟踪指标","text":"<p>grad metrics tool 的开发旨在轻松聚合 statsd 指标并显示它们。</p>","path":["如何调试 sozu"],"tags":[]},{"location":"design_motivation/","level":1,"title":"设计动机","text":"<p>本文档介绍了我们在开发 sōzu 时应牢记的目标。 它将为功能决策、错误修复和重点领域提供信息。</p>","path":["设计动机"],"tags":[]},{"location":"design_motivation/#_2","level":2,"title":"起源","text":"<p>Sōzu 源于 Clever Cloud 在反向代理中处理频繁 配置更改的需求。由于该平台遵循不可变基础设施 原则，应用程序会频繁地从一个虚拟机移动到另一个虚拟机，并且 反向代理的路由配置必须更新。</p> <p>像 HAProxy 这样的经典解决方案被设计为在每次配置 更改时重新启动其进程。这会导致一些问题：</p> <ul> <li>重新启动代理进程将导致 CPU 和 RAM 使用率的暂时飙升（资源使用量翻倍）</li> <li>处理挥之不去的连接：</li> <li>要么我们停止旧进程并丢失它仍在处理的连接</li> <li>要么我们保留旧进程直到连接完成，但如果我们定期重新启动，我们最终可能会有大量旧进程</li> </ul>","path":["设计动机"],"tags":[]},{"location":"design_motivation/#_3","level":2,"title":"主要目标","text":"","path":["设计动机"],"tags":[]},{"location":"design_motivation/#_4","level":3,"title":"运行时配置更改","text":"<p>更改代理的配置应该是在运行时执行的常规任务。 我们不应该仅仅为了处理这个问题而需要重新启动整个进程。</p> <p>这意味着配置管理必须支持动态更改，因此它必须 反映在我们用来驱动 sōzu 的工具中，并且我们需要提供良好的库 来处理该用例。</p>","path":["设计动机"],"tags":[]},{"location":"design_motivation/#_5","level":3,"title":"细粒度修改","text":"<p>我们可以推送小的修改，例如“删除此后端服务器”或 “添加此证书”，而不是重新加载整个状态（就像热重新加载配置文件一样）。 这为我们提供了有关运行时系统的更多信息， 例如知道我们何时可以实际删除后端服务器（一旦没有更多连接 正在使用它）。</p>","path":["设计动机"],"tags":[]},{"location":"design_motivation/#_6","level":3,"title":"有界资源使用","text":"<p>我们应该能够直接在 sōzu 的配置中修复资源使用（CPU、RAM、连接等）的限制。 我们不会在负载下无限期地增加资源使用，而是会立即拒绝新的流量。 这提供了背压，并允许客户端智能地进行重试，并为现有连接保持可预测的延迟和行为。</p>","path":["设计动机"],"tags":[]},{"location":"design_motivation/#_7","level":3,"title":"永不终止的软件","text":"<p>一旦你启动了 sōzu，它应该能够无限期地为流量提供服务。如果发生 导致失败的问题，它不应该导致整个代理崩溃，并且它应该 能够自动恢复处理流量。</p> <p>这种方法的副作用是：二进制升级不应导致流量丢失。</p> <p>这是当前多进程架构背后的主要驱动力。</p>","path":["设计动机"],"tags":[]},{"location":"design_motivation/#_8","level":2,"title":"次要目标","text":"","path":["设计动机"],"tags":[]},{"location":"design_motivation/#_9","level":3,"title":"安全","text":"<p>由于 sōzu 很可能会看到来自大量客户端连接的流量，以及其 TLS 证书的 私钥，因此它应该足够安全以保护其内存。</p> <p>为此，我们选择了 Rust，因为它具有内存安全功能。</p>","path":["设计动机"],"tags":[]},{"location":"design_motivation/#_10","level":3,"title":"可预测性","text":"<p>Sōzu 的内存使用和延迟应该具有非常可预测的行为。 任何不规则性都应被观察和消除。</p> <p>这一立场推动了各种决策：</p> <ul> <li>Rust 使我们能够避免垃圾收集暂停</li> <li>预分配和池化以避免热路径中的某些分配</li> <li>单线程、无共享架构以避免核心之间的同步</li> </ul>","path":["设计动机"],"tags":[]},{"location":"design_motivation/#sozu","level":3,"title":"配置智能应该在工具中，而不是在 sōzu 内部","text":"<p>虽然 sōzu 能够处理细粒度的配置更改，但它的作用不是 连接到阳光下的每个配置管理工具（etcd、kubernetes 等）。 相反，我们应该提供编写连接 sōzu 和系统其余部分的工具的方法。</p> <p>更进一步，处理配置更改的代码应该可以在 sōzu 之外重用。 目前，编写一个从文件加载配置状态的工具， 从 sōzu 获取当前状态，生成差异，然后为差异发送配置消息 到 sōzu 是相当容易的。</p> <p>编写配置工具应该足够容易，并且配置协议应该可以 从任何语言访问。</p>","path":["设计动机"],"tags":[]},{"location":"getting_started/","level":1,"title":"入门","text":"","path":["入门"],"tags":[]},{"location":"getting_started/#rust","level":2,"title":"设置 Rust","text":"<p>确保安装了最新稳定版的 <code>Rust</code>。 我们建议为此使用 rustup。</p> <p>完成此操作后，<code>Rust</code> 应该已完全安装。</p>","path":["入门"],"tags":[]},{"location":"getting_started/#sozu","level":2,"title":"设置 Sōzu","text":"","path":["入门"],"tags":[]},{"location":"getting_started/#_2","level":3,"title":"安装","text":"<p><code>sozu</code> 发布在 crates.io 上。</p> <p>要安装它们，您只需执行 <code>cargo install sozu</code>。</p> <p>它们将被构建并放在 <code>~/.cargo/bin</code> 文件夹中。</p>","path":["入门"],"tags":[]},{"location":"getting_started/#_3","level":3,"title":"从源代码构建","text":"<p>构建 sozu 可执行文件和命令行：</p> <p><code>cd bin &amp;&amp; cargo build --release --locked</code></p> <p><code>--release</code> 参数通知 cargo 在编译 sozu 时打开优化。 仅使用 <code>--release</code> 制作生产版本。</p> <p><code>--locked</code> 标志告诉 cargo 坚持使用 <code>Cargo.lock</code> 中指定的依赖项版本 从而防止依赖项中断。</p>","path":["入门"],"tags":[]},{"location":"how_to_use/","level":1,"title":"如何使用 Sōzu","text":"<p>如果您还没有看过配置文档，我们建议您先看一下，因为您需要知道在配置文件中放些什么。</p>","path":["如何使用 Sōzu"],"tags":[]},{"location":"how_to_use/#_1","level":2,"title":"运行它","text":"<p>如果您使用 <code>cargo install</code> 的方式，<code>sozu</code> 已经 在您的 <code>$PATH</code> 中。</p> <pre><code>sozu start -c &lt;path/to/your/config.toml&gt;\n</code></pre> <p>但是，如果您从源代码构建项目，<code>sozu</code> 会被放置在 <code>target</code> 目录中。</p> <pre><code>./target/release/sozu start -c &lt;path/to/your/config.toml&gt;\n</code></pre> <p><code>cargo build --release --locked</code> 将生成的可执行文件放在 <code>target/release</code> 而不是 <code>target/debug</code> 中。</p> <p>您可以在此处找到一个可用的 <code>config.toml</code> 示例。</p> <p>要启动反向代理：</p> <pre><code>sozu start -c config.toml\n</code></pre> <p>您可以使用 <code>config.toml</code> 文件编辑反向代理的配置。您可以通过该文件声明新的集群、它们的前端和后端。</p> <p>但是为了获得更大的灵活性，您应该使用命令套接字（您可以在配置文件中由 <code>command_socket</code> 设计的路径处找到该 unix 套接字的一端）。</p> <p>您可以使用 <code>sozu</code> 二进制文件作为 CLI 与反向代理进行交互。</p> <p>有关更多信息，请查看命令行文档。</p>","path":["如何使用 Sōzu"],"tags":[]},{"location":"how_to_use/#docker","level":2,"title":"使用 Docker 运行它","text":"<p>该存储库提供了一个基于 <code>alpine:edge</code> 的多阶段 Dockerfile 镜像。</p> <p>您可以通过执行以下命令来构建镜像：</p> <pre><code>docker build -t sozu .\n</code></pre> <p>还有一个 clevercloud/sozu 镜像 它跟随着 master 分支（已过时）。</p> <p>使用以下命令运行它：</p> <pre><code>docker run \\\n  --ulimit nofile=262144:262144 \\\n  --name sozu-proxy \\\n  -v /run/sozu:/run/sozu \\\n  -v /path/to/config/file:/etc/sozu \\\n  -v /my/state/:/var/lib/sozu \\\n  -p 8080:80 \\\n  -p 8443:443 \\\n  sozu\n</code></pre> <p>要构建具有特定版本 Alpine 的镜像：</p> <pre><code>docker build --build-arg ALPINE_VERSION=3.14 -t sozu:main-alpine-3.14 .\n</code></pre>","path":["如何使用 Sōzu"],"tags":[]},{"location":"how_to_use/#configtoml","level":3,"title":"使用自定义 <code>config.toml</code> 配置文件","text":"<p>sozu 的默认配置可以在 <code>../os-build/docker/config.toml</code> 中找到。 如果 <code>/my/custom/config.toml</code> 是您的自定义配置文件的路径和名称，您可以使用卷启动您的 sozu 容器以覆盖默认配置（请注意，此命令中仅使用自定义配置文件的目录路径）：</p> <pre><code>docker run -v /my/custom:/etc/sozu sozu\n</code></pre>","path":["如何使用 Sōzu"],"tags":[]},{"location":"how_to_use/#sozu-docker","level":3,"title":"将 sozu 命令行与 docker 容器一起使用","text":"<p>要从主机使用 <code>sozu</code> CLI 和 docker 容器，您必须使用 docker 卷将 <code>/run/sozu</code> 与主机绑定：</p> <pre><code>docker run -v /run/sozu:/run/sozu sozu\n</code></pre> <p>要更改配置套接字的路径，请修改配置文件中的 <code>command_socket</code> 选项（默认值为 <code>/var/lib/sozu/sock</code>）。</p>","path":["如何使用 Sōzu"],"tags":[]},{"location":"how_to_use/#_2","level":3,"title":"提供初始配置状态","text":"<p>Sōzu 可以使用 JSON 文件为其路由加载初始配置状态。您可以使用卷挂载它，您可以使用卷启动您的 sozu 容器（请注意，此命令中仅使用自定义配置文件的目录路径）：</p> <pre><code>docker run -v /my/state:/var/lib/sozu sozu\n</code></pre> <p>要更改已保存状态文件的路径，请修改配置文件中的 <code>saved_state</code> 选项（默认值为 <code>/var/lib/sozu/state.json</code>）。</p>","path":["如何使用 Sōzu"],"tags":[]},{"location":"how_to_use/#systemd","level":2,"title":"Systemd 集成","text":"<p>存储库在此处提供了一个单元文件。您可以将其复制到 <code>/etc/systemd/system/</code> 并调用 <code>systemctl daemon-reload</code>。</p> <p>这将使 systemd 注意到它，现在您可以使用 <code>systemctl start sozu.service</code> 启动服务。此外，您可以启用它，以便在将来的启动中默认激活它，使用 <code>systemctl enable sozu.service</code>。</p>","path":["如何使用 Sōzu"],"tags":[]},{"location":"lexicon/","level":1,"title":"词汇表","text":"<p>Sōzu 中使用的术语。</p>","path":["词汇表"],"tags":[]},{"location":"lexicon/#_2","level":2,"title":"面向用户","text":"<p>后端 (backend)：Sōzu 将流量重定向到的套接字地址。</p> <p>集群 (cluster)：一组前端、路由规则和后端。</p> <p>前端 (frontend)：集群接收连接的套接字地址。应与匹配的侦听器一起定义。</p> <p>侦听器 (listener)：Sōzu 将接受传入连接的套接字地址。</p> <p>工作进程 (worker)：由主进程管理的 Sōzu 实例。</p>","path":["词汇表"],"tags":[]},{"location":"lexicon/#_3","level":2,"title":"内部机制","text":"<p>会话 (session)：处理前端和后端之间链接的最小单元。每个 传入请求大约有一个会话。</p> <p>代理 (proxy)：处理给定协议的所有流量的单元。在每个 Sōzu 服务器中，都有一个 TCP 代理、 一个 HTTP 代理和一个 HTTPS 代理。</p>","path":["词汇表"],"tags":[]},{"location":"lifetime_of_a_session/","level":1,"title":"会话的生命周期","text":"<p>会话是 Sōzu 业务逻辑的核心单元：将流量从 前端转发到后端，反之亦然。</p> <p>在本文档中，我们将探讨客户端会话从套接字的创建到关闭所发生的一切， 以及描述 HTTP 请求和响应如何发生的所有步骤。</p> <p>在我们深入探讨会话的创建、生命周期和消亡之前，我们需要 理解 Sōzu 中完全隔离的两个概念：</p> <ul> <li>使用 mio crate 进行套接字处理</li> <li>跟踪所有会话的 <code>SessionManager</code></li> </ul>","path":["会话的生命周期"],"tags":[]},{"location":"lifetime_of_a_session/#mio","level":3,"title":"mio 是做什么的？","text":"<p>Mio 允许我们监听套接字事件。例如，我们可以使用 TCP 套接字来 等待连接，当该套接字可读或套接字有 数据要读取，或被对等方关闭，或计时器触发时，mio 会通知我们...</p> <p>Mio 提供了对 linux 系统调用 epoll 的抽象。 这个 epoll 系统调用允许我们注册文件描述符，以便内核在这些文件描述符发生任何事情时通知我们。</p> <p>说到底，套接字只是原始文件描述符。我们使用 mio <code>TcpListener</code>、<code>TcpStream</code> 包装器来包装这些文件描述符。<code>TcpListener</code> 在特定端口上侦听连接。对于每个新连接，它都会创建一个 <code>TcpStream</code>，后续流量将重定向到该 <code>TcpStream</code>（从客户端和到客户端）。</p> <p>这就是我们使用 mio 的全部目的。“订阅”文件描述符事件。</p>","path":["会话的生命周期"],"tags":[]},{"location":"lifetime_of_a_session/#sessionmanager","level":3,"title":"使用 SessionManager 跟踪会话","text":"<p>mio 中的每个订阅都与一个 Token（一个 u64 标识符）相关联。SessionManager 的 工作是将一个 Token 链接到一个将使用该订阅的 <code>ProxySession</code>。 这是通过一个 Slab 完成的，这是一个优化内存使用的键值数据结构：</p> <ul> <li>作为键：mio 提供的 Token</li> <li>作为值：对 <code>ProxySession</code> 的引用</li> </ul> <p>话虽如此，让我们深入探讨会-话的生命周期。</p>","path":["会话的生命周期"],"tags":[]},{"location":"lifetime_of_a_session/#_2","level":3,"title":"什么是代理？","text":"<p>Sōzu 工作进程内部有 3 个代理，每个支持的协议一个：</p> <ul> <li>TCP</li> <li>HTTP</li> <li>HTTPS</li> </ul> <p>代理管理侦听器、前端、后端以及与每个协议（缓冲、解析、错误处理...）相关的业务逻辑。</p>","path":["会话的生命周期"],"tags":[]},{"location":"lifetime_of_a_session/#_3","level":2,"title":"接受连接","text":"<p>Sōzu 使用 TCP 侦听器套接字来获取新连接。它通常会侦听 端口 80 (HTTP) 和 443 (HTTPS)，但也可以有其他用于 TCP 代理的端口， 甚至在其他端口上有 HTTP/HTTPS 代理。</p> <p>对于每个前端，Sōzu：</p> <ol> <li>生成一个新的 Token token</li> <li>使用 mio 将 <code>TcpListener</code> 注册为 token</li> <li>在 <code>SessionManager</code> 中添加一个匹配的 <code>ListenSession</code>，键为 token</li> <li>将 <code>TcpListener</code> 存储在适当的代理（TCP/HTTP/HTTPS）中，键为 token</li> </ol>","path":["会话的生命周期"],"tags":[]},{"location":"lifetime_of_a_session/#tcp","level":3,"title":"TCP 套接字上的事件循环","text":"<p>Sōzu 是热可重构的。我们可以在运行时添加侦听器和前端。对于每个添加的侦听器， SessionManager 将在其 Slab 中存储一个 <code>ListenSession</code>。</p> <p>事件循环 使用 mio 检查所有套接字上的任何活动。 每当 mio 在套接字上检测到活动时，它都会返回一个传递给 <code>SessionManager</code> 的事件。</p> <p>每当客户端连接到前端时： 1. 它到达一个侦听器 2. Sōzu 收到 mio 的通知，称在特定的 Token 上收到了一个 <code>readable</code> 事件 3. 使用 SessionManager，Sōzu 获取相应的 <code>ListenSession</code> 4. Sōzu 确定所使用的协议 5. Token 被传递到适当的代理（TCP/HTTP/HTTPS） 6. 使用 Token，代理确定哪个 <code>TcpListener</code> 触发了事件 7. 代理开始以循环方式从中接受新连接（因为可能不止一个）</p> <p>接受连接意味着将其作为 <code>TcpStream</code> 存储在接受队列中，直到：</p> <ul> <li>没有更多连接要接受</li> <li>或者接受队列已满：https://github.com/sozu-proxy/sozu/blob/e4e7488232ad6523791b94ad201239bcf7eb9b30/lib/src/server.rs#L1204-L1258</li> </ul>","path":["会话的生命周期"],"tags":[]},{"location":"lifetime_of_a_session/#_4","level":3,"title":"消费接受队列","text":"<p>我们从接受队列创建会话，从 最新的会话开始，并丢弃太旧的套接字。</p> <p>当我们接受一个新的连接（<code>TcpStream</code>）时，它可能已经在 侦听器队列中等待了一段时间。内核甚至可能已经有一些可用的数据， 比如一个 HTTP 请求。如果我们处理该请求太慢，客户端可能 在我们将会话转发到后端并且后端响应之前就已经断开了连接（超时）。</p> <p>如果达到了客户端连接的最大数量（由配置中的 <code>max_connections</code> 提供）， 新的连接将保留在队列中。 如果队列已满，我们将丢弃新接受的连接。 通过指定最大并发连接数，我们确保 服务器不会过载，并为现有连接保持可管理的延迟。</p>","path":["会话的生命周期"],"tags":[]},{"location":"lifetime_of_a_session/#_5","level":3,"title":"创建会话","text":"<p>会话的目标是将流量从前端转发到后端，反之亦然。 <code>Session</code> 结构体保存与 会话关联的数据： 令牌、当前超时状态、协议状态、客户端地址... 创建的会话被包装在一个 <code>Rc&lt;RefCell&lt;...&gt;&gt;</code> 中</p> <p>代理为接受队列的每个项目创建一个会话， 使用项目中提供的 <code>TcpStream</code>。 <code>TcpStream</code> 在 mio 中注册了一个新的 Token（称为 frontend_token）。 会话以相同的 Token 添加到 SessionManager 中。</p>","path":["会话的生命周期"],"tags":[]},{"location":"lifetime_of_a_session/#_6","level":3,"title":"检查僵尸会话","text":"<p>因为在创建和删除会话时可能会发生错误，并且其中一些 可能会被“遗忘”，所以有一个名为 “僵尸检查器” 的常规任务， 它会检查列表中的会话并终止那些卡住或太旧的会话。</p>","path":["会话的生命周期"],"tags":[]},{"location":"lifetime_of_a_session/#_7","level":2,"title":"会话如何从前端套接字读取数据","text":"<p>当数据从网络到达 <code>TcpStream</code> 时，它会存储在内核 缓冲区中，内核会通知事件循环套接字是可读的。</p> <p>与侦听套接字一样，与 TCP 套接字关联的令牌将获得一个 “可读”事件，我们将使用该令牌来查找与哪个会话 关联。然后我们调用 <code>Session::update_readiness</code> 来通知它新的 套接字状态。</p> <p>然后我们调用 <code>Session::ready</code> 让它读取数据、解析等。 该方法将在一个循环中运行 (https://github.com/sozu-proxy/sozu/blob/e4e7488232ad6523791b94ad201239bcf7eb9b30/lib/src/https_openssl.rs#L548-L692)，</p>","path":["会话的生命周期"],"tags":[]},{"location":"lifetime_of_a_session/#_8","level":3,"title":"引入状态机","text":"<p>会话的 <code>Session::readable</code> 方法 被调用。然后它将调用底层 状态机的相同方法。</p> <p>状态机是实现协议的地方。会话可能需要 在其生命周期内识别不同的协议，具体取决于其配置， 并在它们之间进行 升级。它们都在 protocol 目录中。</p> <p>示例： - 一个 HTTPS 会话可以从一个名为 <code>ExpectProxyProtocol</code> 的状态开始 - 一旦 expect 协议运行完毕，会话将升级到 TLS 握手状态：<code>HandShake</code> - 握手完成后，我们有一个 TLS 流，会话升级到 <code>HTTP</code> 状态 - 如果客户端需要，会话可以切换到 WebSocket 连接：<code>WebSocket</code></p> <p>现在，假设我们当前正在使用 HTTP 1 协议。会话调用了 <code>readable()</code> 方法。</p>","path":["会话的生命周期"],"tags":[]},{"location":"lifetime_of_a_session/#_9","level":3,"title":"查找后端","text":"<p>我们需要解析 HTTP 请求以找出其：</p> <ol> <li>主机名</li> <li>路径</li> <li>HTTP 动词</li> </ol> <p>我们将首先尝试 从套接字读取数据 到前端缓冲区。如果没有错误（关闭的套接字等），我们将在 <code>readable_parse()</code> 中处理该数据。</p> <p>HTTP 实现拥有 两个较小的状态机， <code>RequestState</code> 和 <code>ResponseState</code>，它们指示我们在解析 请求或响应中的位置，并存储有关它们的数据。</p> <p>当我们从客户端接收到第一个字节时，两者都处于 <code>Initial</code> 状态。 我们 从前端缓冲区解析数据 直到我们达到一个请求状态，其中标头被完全解析。如果 没有足够的数据，我们将等待更多数据到达套接字并重新开始 解析。</p> <p>一旦我们完成了解析标头，并找到了我们正在寻找的内容，我们将 返回 SessionResult::ConnectBackend 以通知会话它应该找到一个后端服务器来发送数据。</p>","path":["会话的生命周期"],"tags":[]},{"location":"lifetime_of_a_session/#_10","level":2,"title":"连接到后端服务器","text":"<p>会话： 1. 查找要连接到哪个集群 2. 向 SessionManager 请求一个名为 <code>back_token</code> 的新有效 Token 3. 请求连接到集群    - 适当的代理查找后端（添加详细信息） 4. 使用 <code>back_token</code> 在 mio 中注册新的 <code>TcpStream</code> 5. 使用 <code>back_token</code> 将自身插入 SessionManager</p> <p>同一个会话现在在 SessionManager 中存储了两次：</p> <ol> <li>一次使用前端令牌作为键</li> <li>其次使用后端令牌作为键</li> </ol> <p>如果 Sōzu 找不到集群，它会向客户端响应默认的 HTTP 404 Not Found 响应。 一个会话可以尝试连接到后端 3 次。如果所有尝试都失败，Sōzu 会响应默认的 HTTP 503 Service Unavailable 响应。如果 Sōzu 找到了一个集群，但所有相应的 后端都已关闭（或没有响应），则会发生这种情况。</p>","path":["会话的生命周期"],"tags":[]},{"location":"lifetime_of_a_session/#_11","level":3,"title":"保持会话活动","text":"<p>如果 HTTP 请求的 Connection 标头设置为 Keep-Alive， 则在接收到响应后可以保持底层 TCP 连接， 以发送更多请求。由于 Sōzu 支持在 URL 和 主机名上进行路由，因此下一个请求可能会转到不同的集群。 因此，当我们从请求中获取集群 ID 时，我们会检查它是否与 前一个相同，如果相同，我们会测试后端套接字是否仍然 有效。如果是，我们可以重用它。否则，我们将用 一个新的后端套接字替换它。</p>","path":["会话的生命周期"],"tags":[]},{"location":"lifetime_of_a_session/#_12","level":3,"title":"粘性会话：将一个前端只固定到一个后端","text":"<p>这是一种路由机制，我们查看请求中的 cookie。所有 具有相同 id 的请求都将发送到同一个后端服务器。</p> <p>该查找将返回一个结果，具体取决于哪些后端服务器被 认为是有效的（如果它们正在正确响应）以及为集群配置的负载平衡 策略。 如果找到了后端，我们将打开一个到后端服务器的 TCP 连接， 否则我们将返回一个 HTTP 503 响应。</p>","path":["会话的生命周期"],"tags":[]},{"location":"lifetime_of_a_session/#_13","level":2,"title":"将数据发送到后端套接字","text":"<p>然后我们等待来自后端连接的可写事件，然后我们可以开始 将挂起的请求转发给它。 如果出现错误，我们会重试连接到同一集群中的另一个后端服务器。</p>","path":["会话的生命周期"],"tags":[]},{"location":"lifetime_of_a_session/#_14","level":2,"title":"大转弯：从后端转发到前端","text":"<p>如上所述，我们有一个名为 <code>ResponseState</code> 的小型状态机，用于 解析来自后端的流量。整个逻辑基本相同。</p> <p>我们监视后端的可读性和前端的可写性，并将流量从 一个转移到另一个。</p>","path":["会话的生命周期"],"tags":[]},{"location":"lifetime_of_a_session/#_15","level":2,"title":"会话结束","text":"<p>一旦 <code>ResponseState</code> 达到“已完成”状态并且每个字节都已发送 回客户端，请求的完整生命周期就结束了。会话 达到 <code>CloseSession</code> 状态并从 <code>SessionManager</code> 的 slab 中移除， 其套接字也从 mio 中注销。</p> <p>但是，如果请求具有 Keep-Alive 标头，则会话将被重用 并等待新请求。这是会话的“重置”。</p>","path":["会话的生命周期"],"tags":[]},{"location":"recipes/","level":1,"title":"配方：常见问题的解决方案、提示和技巧","text":"<ul> <li>配方：常见问题的解决方案、提示和技巧</li> <li>以非 root 用户身份使用端口 80 或 443</li> <li>权能</li> <li>iptables</li> <li>高可用性架构</li> </ul>","path":["配方：常见问题的解决方案、提示和技巧"],"tags":[]},{"location":"recipes/#root-80-443","level":1,"title":"以非 root 用户身份使用端口 80 或 443","text":"<p>1024 以下的端口号通常非 root 用户无法访问。使用 sōzu， 我们经常需要监听端口 80 (HTTP) 和 443 (HTTPS)。为避免以 root 身份运行 sōzu，以下是一些访问这些端口的解决方案。</p>","path":["配方：常见问题的解决方案、提示和技巧"],"tags":[]},{"location":"recipes/#_2","level":2,"title":"权能","text":"<p>最近的 linux 版本 (&gt; 2.2) 具有一项称为权能的功能，可以 根据上下文激活。要在保留端口上创建侦听套接字， 我们需要 <code>CAP_NET_BIND_SERVICE</code> 权能。</p> <p>我们可以通过创建一个非特权 <code>sozu</code> 用户并编写以下 systemd 单元文件来设置它：</p> <pre><code>[Unit]\nDescription=Sozu - 一个 HTTP 反向代理，可在运行时配置，快速且安全，用 Rust 构建。\nDocumentation=https://docs.rs/sozu/\nAfter=network-online.target\nWants=network-online.target\n\n[Service]\nExecStart=/usr/bin/sozu start --config /etc/sozu/config.toml\nExecReload=/usr/bin/sozu --config /etc/sozu/config.toml reload\nRestart=on-failure\nUser=sozu\nAmbientCapabilities=CAP_NET_BIND_SERVICE\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p>也可以直接将权能赋予 sozu 二进制文件，使用 <code>setcap 'cap_net_bind_service=+eip' /usr/bin/sozu</code>， 但这样任何可以执行 sōzu 的用户都可以访问保留端口（因此他们 可以为 SSH、SMTP 等设置 TCP 代理到自己的软件）。 建议使用单元文件的方式。</p>","path":["配方：常见问题的解决方案、提示和技巧"],"tags":[]},{"location":"recipes/#_3","level":2,"title":"使用非特权端口","text":"<p>可以使用不同的防火墙将来自保留端口的连接路由到其他非特权端口。 最常见的重定向遵循 80 -&gt; 8080 和 443 -&gt; 8443。</p>","path":["配方：常见问题的解决方案、提示和技巧"],"tags":[]},{"location":"recipes/#iptables","level":3,"title":"iptables","text":"<p>可以使用 iptables，使用简单的 nat。</p> <pre><code>iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080\niptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-ports 8443\n</code></pre>","path":["配方：常见问题的解决方案、提示和技巧"],"tags":[]},{"location":"recipes/#firewalld","level":3,"title":"firewalld","text":"<p>firewalld 的语法与 iptables 非常相似。可以使用 <code>--permanent</code> 使其永久化。</p> <pre><code>firewall-cmd --direct --add-rule ipv4 nat PREROUTING 0 -p tcp --dport 80 -j REDIRECT --to-port 8080\nfirewall-cmd --direct --add-rule ipv4 nat PREROUTING 0 -p tcp --dport 443 -j REDIRECT --to-port 8443\n</code></pre> <p>请注意，与 sōzu 具有相同 uid 的任何软件都将能够监听 8080 和 8443 端口，因为这些端口是非特权的，并且 sōzu 使用 <code>SO_REUSEPORT</code> 选项设置侦听套接字。</p>","path":["配方：常见问题的解决方案、提示和技巧"],"tags":[]},{"location":"recipes/#_4","level":1,"title":"高可用性架构","text":"<p>待办事项</p>","path":["配方：常见问题的解决方案、提示和技巧"],"tags":[]},{"location":"tools_libraries/","level":1,"title":"工具和库","text":"","path":["工具和库"],"tags":[]},{"location":"tools_libraries/#_2","level":2,"title":"其他语言的客户端","text":"<ul> <li>Elixir - exsozu</li> </ul>","path":["工具和库"],"tags":[]},{"location":"why_you_should_use/","level":1,"title":"为什么你应该使用 Sōzu","text":"<ul> <li>热配置： Sozu 可以在运行时通过安全的 unix 套接字接收配置更改。</li> <li>无需重启即可升级： Sozu 始终在线，这意味着它可以在仍在处理请求的同时自行升级。</li> </ul>","path":["为什么你应该使用 Sōzu"],"tags":[]}]}